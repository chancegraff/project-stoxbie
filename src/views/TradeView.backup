// import React, {
//     useCallback, useEffect, useMemo, useState,
//   } from "react";
//   import { useStyletron } from "baseui/dist";
//   import { Block } from "baseui/dist/block";
//   import { FlexGridItem } from "baseui/dist/flex-grid";
//   import {
//     closestIndexTo, parseISO,
//   } from "date-fns";
//   import { HistoricalPrice } from "iex";
//   import useResizeObserver from "use-resize-observer";

//   import { useCookie } from "services/Cookies";
//   import { handleUnloadCreator } from "services/Utilities";
//   import {
//     AspectRatioBox, AspectRatioItem,
//   } from "templates/AspectRatio";
//   import PageBreadcrumb from "templates/PageBreadcrumb";
//   import PageContent from "templates/PageContent";
//   import PageError from "templates/PageError";
//   import FlexGrid from "components/BaseUI/FlexGrid";
//   import StockChart from "components/StockChart";
//   import TimeControl from "components/TimeControl";
//   import TradeControl from "components/TradeControl";
//   import TradeHistory from "components/TradeHistory";

//   type Props = {
//     date?: Date;
//     error?: string;
//     prices?: HistoricalPrice[];
//     ticker?: string;
//   };

//   const getPriceIndexes = (
//     prices: HistoricalPrice[],
//     date: Date,
//   ) =>
//   {
//     const priceDates = prices.map(({ date: dateString }) =>
//     {
//       return parseISO(dateString);
//     });
//     const startDateIndex = closestIndexTo(
//       date,
//       priceDates,
//     );
//     const endDateIndex = startDateIndex > -1
//       ? startDateIndex - 730
//       : 0;

//     return [
//       endDateIndex,
//       startDateIndex,
//     ];
//   };

//   const canGetNextPrice = (
//     prices: HistoricalPrice[],
//     nextPriceIndexes: number[],
//   ) =>
//   {
//     const [
//       , startDateIndex,
//     ] = nextPriceIndexes;

//     return prices.length > startDateIndex;
//   };

//   const setNextPrices = (
//     prices: HistoricalPrice[],
//     priceIndexes: number[],
//     {
//       setPastPrices,
//       setNextPriceIndexes,
//     }: {
//       setPastPrices: DispatchSetStateAction<HistoricalPrice[] | undefined>;
//       setNextPriceIndexes: DispatchSetStateAction<number[] | undefined>;
//     },
//   ) =>
//   {
//     const nextPrices = prices.slice(...priceIndexes);

//     setPastPrices(nextPrices);
//     setNextPriceIndexes(priceIndexes.map((index) =>
//     {
//       return index + 1;
//     }));
//   };

//   const getOpenedTrade = (
//     previousTrade: HistoricalTrade,
//     shareClose: number,
//     shareCount: number,
//   ): HistoricalTradeStarted =>
//   {
//     const openPrice = shareClose;
//     const openCount = Math.abs(shareCount);
//     const openModifier = (shareCount / openCount) as -1 | 1;
//     const openDate = new Date();
//     const openBalance = openCount * openPrice;
//     const currentTrade = {
//       ...previousTrade,
//       openPrice,
//       openCount,
//       openModifier,
//       openBalance,
//       openDate,
//     };

//     return currentTrade;
//   };

//   const getClosedTrade = (
//     previousTrade: HistoricalTradeStarted,
//     shareClose: number,
//     shareCount: number,
//   ): HistoricalTradeFinished =>
//   {
//     const closePrice = shareClose;
//     const closeCount = Math.abs(shareCount);
//     const closeModifier = (shareCount / closeCount) as -1 | 1;
//     const closeDate = new Date();
//     const closeBalance = closeCount * shareClose;
//     const changePrice = (closePrice - previousTrade.openPrice) * previousTrade.openModifier;
//     const pricePaid = closeCount * previousTrade.openPrice;
//     const changeBalance = (closeBalance - pricePaid) * previousTrade.openModifier;
//     const changePercent = changeBalance / pricePaid;
//     const currentTrade = {
//       ...previousTrade,
//       changeBalance,
//       changePercent,
//       changePrice,
//       closePrice,
//       closeCount,
//       closeModifier,
//       closeBalance,
//       closeDate,
//     };

//     return currentTrade;
//   };

//   const TradeView: React.FC<Props> = ({
//     prices,
//     date,
//     error,
//     ticker,
//   }) =>
//   {
//     const [
//       , theme,
//     ] = useStyletron();
//     const {
//       ref,
//       width = 1,
//       height = 1,
//     } = useResizeObserver<HTMLDivElement>();

//     const [
//       pastPrices,
//       setPastPrices,
//     ] = useState<HistoricalPrice[]>();
//     const [
//       nextPriceIndexes,
//       setNextPriceIndexes,
//     ] = useState<number[]>();

//     const [
//       pastTrades,
//       setPastTrades,
//     ] = useCookie<HistoricalTradeFinished[]>(
//       "pastTrades",
//       [],
//     );
//     const [
//       currentTrades,
//       setCurrentTrades,
//     ] = useCookie<HistoricalTradeStarted[]>(
//       "currentTrades",
//       [],
//     );
//     const [
//       playerLedger,
//       setPlayerLedger,
//     ] = useCookie<HistoricalLedger[]>(
//       "playerLedger",
//       [ {
//         totalBalance: 10000,
//         totalChange: 0,
//         totalReturns: 0,
//       } ],
//     );

//     const currentPrice = useMemo(
//       () =>
//       {
//         return pastPrices && pastPrices[pastPrices.length - 1];
//       },
//       [ pastPrices ],
//     );
//     const currentLedger = useMemo(
//       () =>
//       {
//         const [ nextLedger ] = playerLedger;

//         return nextLedger;
//       },
//       [ playerLedger ],
//     );
//     const visibleTrade = useMemo(
//       () =>
//       {
//         if (currentTrades.length > 0)
//         {
//           const [ newestOpenedTrade ] = currentTrades;
//           const highestOpenedTrade = currentTrades.reduceRight(
//             (
//               previousTrade,
//               nextTrade,
//             ) =>
//             {
//               return previousTrade.openPrice > nextTrade.openPrice
//                 ? previousTrade
//                 : nextTrade;
//             },
//             newestOpenedTrade,
//           );

//           return highestOpenedTrade;
//         }
//       },
//       [ currentTrades ],
//     );

//     const updateCurrentTrades = useCallback(
//       (nextTrades: HistoricalTradeStarted[]) =>
//       {
//         setCurrentTrades(
//           nextTrades,
//           30,
//         );
//       },
//       [ setCurrentTrades ],
//     );
//     const updatePastTrades = useCallback(
//       (nextTrades: HistoricalTradeFinished[]) =>
//       {
//         setPastTrades(
//           [
//             ...nextTrades,
//             ...pastTrades,
//           ],
//           30,
//         );
//       },
//       [
//         pastTrades,
//         setPastTrades,
//       ],
//     );
//     const updatePlayerLedger = useCallback(
//       (nextLedger: HistoricalLedger) =>
//       {
//         setPlayerLedger(
//           [
//             nextLedger,
//             ...playerLedger,
//           ],
//           30,
//         );
//       },
//       [
//         playerLedger,
//         setPlayerLedger,
//       ],
//     );

//     const openTrade = useCallback(
//       (
//         sharePrice: number,
//         shareCount: number,
//       ) =>
//       {
//         // console.debug(`Opening ${shareCount} shares at $${sharePrice} will cost ${Math.abs(shareCount * sharePrice)}`);

//         // console.group("Opening order");

//         if (ticker && date)
//         {
//           const nextTrade = { ticker };
//           const { ...nextPlayerLedger } = currentLedger;
//           const {
//             totalBalance: previousTotalBalance,
//             totalChange: previousTotalChange,
//             totalReturns: previousTotalReturns,
//           } = currentLedger;
//           const openedTrade = getOpenedTrade(
//             nextTrade,
//             sharePrice,
//             shareCount,
//           );

//           // console.debug(
//           //   `Opened new trade for a cost of ${openedTrade.openBalance}`,
//           //   { openedTrade: { ...openedTrade } },
//           // );

//           nextPlayerLedger.totalBalance = previousTotalBalance - (openedTrade.openPrice * openedTrade.openCount);
//           nextPlayerLedger.totalChange = previousTotalChange;
//           nextPlayerLedger.totalReturns = previousTotalReturns;

//           // console.debug(`Our current total balance is ${previousTotalBalance}`);
//           // console.debug(
//           //   `Next total balance is ${nextPlayerLedger.totalBalance}`,
//           //   { [`${previousTotalBalance} - ${openedTrade.openBalance} === ${nextPlayerLedger.totalBalance}`]: previousTotalBalance - openedTrade.openBalance === nextPlayerLedger.totalBalance },
//           // );
//           // console.debug(
//           //   `Opened trade has an open balance of ${openedTrade.openBalance}`,
//           //   { [`${openedTrade.openPrice} * ${openedTrade.openCount} === ${openedTrade.openBalance}`]: openedTrade.openPrice * openedTrade.openCount === openedTrade.openBalance },
//           // );

//           const nextCurrentTrades = [
//             openedTrade,
//             ...currentTrades,
//           ];

//           // console.debug(
//           //   `Added trade to next current trades list, making the next current trades list length ${nextCurrentTrades.length}`,
//           //   { [`${nextCurrentTrades.length} === ${currentTrades.length} + 1`]: nextCurrentTrades.length === currentTrades.length + 1 },
//           // );
//           // console.debug(
//           //   "Updating current trades and player ledger",
//           //   {
//           //     nextCurrentTrades: [ ...nextCurrentTrades ],
//           //     nextPlayerLedger: { ...nextPlayerLedger },
//           //   },
//           // );

//           updateCurrentTrades(nextCurrentTrades);
//           updatePlayerLedger(nextPlayerLedger);
//         }

//         // console.groupEnd();
//       },
//       [
//         ticker,
//         date,
//         currentTrades,
//         currentLedger,
//         updateCurrentTrades,
//         updatePlayerLedger,
//       ],
//     );
//     const closeTrade = useCallback(
//       (
//         sharePrice: number,
//         shareCount: number,
//       ) =>
//       {
//         // console.debug(`Closing ${shareCount} shares at $${sharePrice} from a total of ${currentTrades.length} trades.`);

//         // console.group("Closing order");

//         if (currentTrades.length > 0)
//         {
//           const { ...nextPlayerLedger } = currentLedger;
//           const [ ...nextCurrentTrades ] = currentTrades;
//           const nextPastTrades: HistoricalTradeFinished[] = [];

//           const [ ...sortedCurrentTrades ] = currentTrades.sort((
//             previousTrade,
//             nextTrade,
//           ) =>
//           {
//             return previousTrade.openPrice - nextTrade.openPrice;
//           });
//           const {
//             totalBalance: previousTotalBalance,
//             totalReturns: previousTotalReturns,
//           } = currentLedger;

//           let remainingOrderShareCount = Math.abs(shareCount);

//           // console.debug(
//           //   "Sorted current trades should be organized from lowest open price first to highest open price last.",
//           //   { [`${sortedCurrentTrades[0].openPrice} <= ${sortedCurrentTrades[sortedCurrentTrades.length - 1].openPrice}`]: sortedCurrentTrades[0].openPrice <= sortedCurrentTrades[sortedCurrentTrades.length - 1].openPrice },
//           //   {
//           //     currentTrades: [ ...currentTrades ],
//           //     nextCurrentTrades: [ ...nextCurrentTrades ],
//           //     sortedCurrentTrades: [ ...sortedCurrentTrades ],
//           //   },
//           // );

//           while (
//             remainingOrderShareCount > 0 &&
//             sortedCurrentTrades.length > 0
//           )
//           {
//             // console.group("Closing trade");

//             // console.debug(`Order has ${remainingOrderShareCount} shares left and there are ${sortedCurrentTrades.length} trades left.`);

//             // Fill as much of the order as we can with the lowest-opened trade
//             const lowestTrade = sortedCurrentTrades.shift() as HistoricalTradeStarted;
//             const countPossible = Math.min(
//               lowestTrade.openCount,
//               remainingOrderShareCount,
//             );
//             const closedTrade = getClosedTrade(
//               lowestTrade,
//               sharePrice,
//               countPossible,
//             );

//             // console.debug(`Closing ${countPossible} out of ${lowestTrade.openCount} total shares from trade where open was $${lowestTrade.openPrice}.`);
//             // console.debug(
//             //   `With ${countPossible} shares at $${lowestTrade.openPrice}, this trade cost ${lowestTrade.openPrice * countPossible}.`,
//             //   { [`(${lowestTrade.openPrice} * ${countPossible}) === (${closedTrade.openPrice} * ${closedTrade.closeCount})`]: (lowestTrade.openPrice * countPossible) === (closedTrade.openPrice * closedTrade.closeCount) },
//             // );
//             // console.debug(
//             //   `But, trading ${countPossible} shares at $${sharePrice} gave us back ${countPossible * sharePrice}.`,
//             //   { [`(${countPossible} * ${sharePrice}) === (${closedTrade.closeCount} * ${closedTrade.closePrice})`]: (countPossible * sharePrice) === (closedTrade.closeCount * closedTrade.closePrice) },
//             // );
//             // console.debug(
//             //   `This means we made a profit of $${(countPossible * sharePrice) - (lowestTrade.openPrice * countPossible)}.`,
//             //   { [`(${countPossible * sharePrice} - ${lowestTrade.openPrice * countPossible}) === (${closedTrade.closeCount * closedTrade.closePrice} - ${closedTrade.openPrice * closedTrade.closeCount})`]: ((countPossible * sharePrice) - (lowestTrade.openPrice * countPossible)) === ((closedTrade.closeCount * closedTrade.closePrice) - (closedTrade.openPrice * closedTrade.closeCount)) },
//             //   {
//             //     lowestTrade: { ...lowestTrade },
//             //     closedTrade: { ...closedTrade },
//             //   },
//             // );

//             // Add closed trade to front of collection
//             nextPastTrades.unshift(closedTrade);

//             // Update ledger values and remaining shares in order
//             remainingOrderShareCount -= countPossible;
//             nextPlayerLedger.totalBalance = previousTotalBalance + (closedTrade.closePrice * closedTrade.closeCount);
//             nextPlayerLedger.totalReturns = previousTotalReturns + closedTrade.changeBalance;
//             nextPlayerLedger.totalChange = nextPlayerLedger.totalReturns / nextPlayerLedger.totalBalance;

//             // console.debug(`Our current total balance is ${previousTotalBalance}`);
//             // console.debug(
//             //   `Next total balance is ${nextPlayerLedger.totalBalance}`,
//             //   { [`${previousTotalBalance} + ${closedTrade.closeBalance} === ${nextPlayerLedger.totalBalance}`]: previousTotalBalance + closedTrade.closeBalance === nextPlayerLedger.totalBalance },
//             // );
//             // console.debug(
//             //   `Closed trade has an close balance of ${closedTrade.closeBalance}`,
//             //   { [`${closedTrade.closePrice} * ${closedTrade.closeCount} === ${closedTrade.closeBalance}`]: closedTrade.closePrice * closedTrade.closeCount === closedTrade.closeBalance },
//             // );

//             // Remove the closed trade from current trades
//             const lowestTradeIndex = nextCurrentTrades.indexOf(lowestTrade);

//             nextCurrentTrades.splice(
//               lowestTradeIndex,
//               1,
//             );

//             // console.debug(
//             //   `Removed trade at index ${lowestTradeIndex} from next current trades list, making next current trades length ${nextCurrentTrades.length}.`,
//             //   {
//             //     currentTrades: [ ...currentTrades ],
//             //     nextCurrentTrades: [ ...nextCurrentTrades ],
//             //     sortedCurrentTrades: [ ...sortedCurrentTrades ],
//             //   },
//             // );
//             // console.debug(
//             //   `Current trades length is ${currentTrades.length}, and next current trades length is ${nextCurrentTrades.length}`,
//             //   { [`${nextCurrentTrades.length} <= ${currentTrades.length}`]: nextCurrentTrades.length <= currentTrades.length },
//             // );

//             // Check if there are any shares left in the trade we just removed
//             const remainingTradeShareCount = closedTrade.openCount - closedTrade.closeCount;

//             // console.debug(
//             //   `With ${countPossible} shares closed from this trade and ${lowestTrade.openCount} total shares, there are ${lowestTrade.openCount - countPossible} shares left in the trade.`,
//             //   { [`(${lowestTrade.openCount} - ${countPossible}) === (${closedTrade.openCount} - ${closedTrade.closeCount})`]: (lowestTrade.openCount - countPossible) === (closedTrade.openCount - closedTrade.closeCount) },
//             // );

//             if (remainingTradeShareCount > 0)
//             {
//               // Copy the previous share, update its openBalance and openCount, and add it back in the same place
//               const remainingBalance = closedTrade.openPrice * remainingTradeShareCount;
//               const nextTrade: HistoricalTradeStarted = {
//                 ...lowestTrade,
//                 openBalance: remainingBalance,
//                 openCount: remainingTradeShareCount,
//               };

//               // console.debug(`There are ${remainingTradeShareCount} shares left in this trade`);

//               nextCurrentTrades.splice(
//                 lowestTradeIndex,
//                 0,
//                 nextTrade,
//               );

//               // console.debug(
//               //   `Added trade at index ${lowestTradeIndex} back to next current trades list, making next current trades length ${nextCurrentTrades.length}.`,
//               //   {
//               //     currentTrades: [ ...currentTrades ],
//               //     nextCurrentTrades: [ ...nextCurrentTrades ],
//               //     sortedCurrentTrades: [ ...sortedCurrentTrades ],
//               //   },
//               // );
//             }

//             // console.groupEnd();
//           }

//           // console.debug(
//           //   `There are ${remainingOrderShareCount} shares left to exchange in the order so the state is being updated.`,
//           //   {
//           //     nextCurrentTrades: [ ...nextCurrentTrades ],
//           //     nextPastTrades: [ ...nextPastTrades ],
//           //     nextPlayerLedger: { ...nextPlayerLedger },
//           //   },
//           // );

//           // Update state values
//           updateCurrentTrades(nextCurrentTrades);
//           updatePastTrades(nextPastTrades);
//           updatePlayerLedger(nextPlayerLedger);
//         }

//         // console.groupEnd();
//       },
//       [
//         currentTrades,
//         currentLedger,
//         updatePlayerLedger,
//         updateCurrentTrades,
//         updatePastTrades,
//       ],
//     );

//     const handleLoad = useCallback(
//       (
//         nextPrices?: HistoricalPrice[],
//         nextDate?: Date,
//       ) =>
//       {
//         if (nextPrices && nextDate)
//         {
//           const priceIndexes = getPriceIndexes(
//             nextPrices,
//             nextDate,
//           );

//           setNextPrices(
//             nextPrices,
//             priceIndexes,
//             {
//               setNextPriceIndexes,
//               setPastPrices,
//             },
//           );
//         }
//       },
//       [],
//     );
//     const handleTrade = useCallback(
//       (
//         sharePrice: number,
//         shareCount: number,
//       ) =>
//       {
//         // console.group("Order");

//         // console.debug(`Trade coming in for ${shareCount} shares at $${sharePrice}.`);

//         const currentTradeType = shareCount / Math.abs(shareCount);
//         const previousTradeOpposite = visibleTrade && visibleTrade.openModifier * -1;

//         // console.debug(`Trade type is ${currentTradeType} and previous trade type's opposite is ${previousTradeOpposite}.`);

//         if (currentTradeType === previousTradeOpposite)
//         {
//           closeTrade(
//             sharePrice,
//             shareCount,
//           );
//         }
//         else
//         {
//           openTrade(
//             sharePrice,
//             shareCount,
//           );
//         }

//         // console.groupEnd();
//       },
//       [
//         visibleTrade,
//         openTrade,
//         closeTrade,
//       ],
//     );
//     const handleContinue = useCallback(
//       () =>
//       {
//         if (
//           prices &&
//           nextPriceIndexes &&
//           canGetNextPrice(
//             prices,
//             nextPriceIndexes,
//           )
//         )
//         {
//           setNextPrices(
//             prices,
//             nextPriceIndexes,
//             {
//               setNextPriceIndexes,
//               setPastPrices,
//             },
//           );
//         }
//       },
//       [
//         prices,
//         nextPriceIndexes,
//       ],
//     );

//     useEffect(
//       () =>
//       {
//         if (!pastPrices)
//         {
//           handleLoad(
//             prices,
//             date,
//           );
//         }
//       },
//       [
//         pastPrices,
//         handleLoad,
//         prices,
//         date,
//       ],
//     );

//     useEffect(
//       () =>
//       {
//         return handleUnloadCreator([
//           setPastPrices,
//           setNextPriceIndexes,
//         ]);
//       },
//       [],
//     );

//     if (error)
//     {
//       return (
//         <PageError>
//           {error}
//         </PageError>
//       );
//     }

//     return (
//       <PageContent>
//         <Block
//           marginBottom={theme.sizing.scale800}
//           width="100%"
//         >
//           <PageBreadcrumb />
//         </Block>
//         <FlexGrid
//           flexWrap={
//             [
//               true,
//               true,
//               true,
//               false,
//             ]
//           }
//         >
//           <AspectRatioBox component={FlexGridItem}>
//             <AspectRatioItem ref={ref}>
//               <StockChart
//                 prices={pastPrices}
//                 resolution={
//                   [
//                     width,
//                     height,
//                   ]
//                 }
//               />
//             </AspectRatioItem>
//           </AspectRatioBox>
//           <FlexGridItem
//             display="flex"
//             flexDirection="column"
//             height={`${height}px`}
//             maxWidth={
//               [
//                 "100%",
//                 "100%",
//                 "25%",
//               ]
//             }
//             minWidth={
//               [
//                 "auto",
//                 "30%",
//                 "25%",
//               ]
//             }
//           >
//             <TimeControl handleContinue={handleContinue} />
//             <TradeControl
//               currentBalance={currentLedger.totalBalance}
//               currentPrice={currentPrice}
//               handleTrade={handleTrade}
//             />
//             <TradeHistory
//               currentPrice={currentPrice}
//               visibleTrade={visibleTrade}
//               handleTrade={handleTrade}
//               pastTrades={pastTrades}
//               playerLedger={currentLedger}
//               pastLedgers={playerLedger}
//               currentTrades={currentTrades}
//             />
//           </FlexGridItem>
//         </FlexGrid>
//       </PageContent>
//     );
//   };

//   export default TradeView;
